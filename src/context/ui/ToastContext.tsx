import { randomUUID } from 'expo-crypto'
import { createContext, ReactNode, useCallback, useContext, useMemo, useState } from 'react'

/**
 * A toast message entry.
 */
export type ToastMessage = {
  /**
   * The ID of this toast, autogenerated, not stable.
   */
  id: string

  /**
   * The type of the toast.
   */
  type: 'notice' | 'info' | 'warning' | 'error'

  /**
   * The content. Can be a React node.
   */
  content: ReactNode | string

  /**
   * The time at which the message was queued.
   */
  queued: number

  /**
   * The lifetime at initialization.
   */
  lifetime: number

  /**
   * A group key, freely pickable if multiple consumers render toasts.
   */
  group?: any
}

/**
 * Type of the toast context.
 */
export type ToastContextType = {
  /**
   * Current toast messages.
   */
  messages: ToastMessage[]

  /**
   * Offers a toast for presentation.
   * @param type The type of the toast.
   * @param content The content. Can be a React node.
   * @param lifetime The lifetime.
   * @param group A group key, freely pickable if multiple consumers render toasts.
   */
  toast(type: 'notice' | 'info' | 'warning' | 'error', content: ReactNode | string, lifetime?: number, group?: any): void

  /**
   * Dismisses a toast.
   * @param id The ID of the toast.
   */
  dismiss(id: string): void
}

/**
 * Toast context object.
 */
export const ToastContext = createContext<ToastContextType | undefined>(undefined)
ToastContext.displayName = 'ToastContext'

/**
 * Prop types for a toast provider.
 */
export type ToastContextProviderProps = {
  /**
   * The children to provide for.
   */
  children?: ReactNode | undefined
}

/**
 * Provides toast management.
 * @param children The children to provide for.
 * @constructor
 */
export const ToastProvider = ({ children }: ToastContextProviderProps) => {
  const [messages, setMessages] = useState<ToastMessage[]>([])
  const toast = useCallback((type: 'notice' | 'info' | 'warning' | 'error', content: ReactNode | string, lifetime = 5000, group?: any) => {
    const queued = Date.now()
    const message = { id: randomUUID(), type, content, queued, lifetime, group }

    setMessages((current) => [...current, message])
    setTimeout(() => {
      setMessages((current) => {
        const i = current.indexOf(message)
        return i < 0 ? current : current.slice(0, i).concat(current.slice(i + 1))
      })
    }, lifetime)
  }, [])

  const dismiss = useCallback((id: string) => {
    setMessages((current) => {
      const i = current.findIndex((message) => id === message.id)
      return i < 0 ? current : current.slice(0, i).concat(current.slice(i + 1))
    })
  }, [])

  const value = useMemo(() => ({ messages, toast, dismiss }), [messages, toast, dismiss])
  return <ToastContext.Provider value={value}>{children}</ToastContext.Provider>
}

/**
 * Uses the toast context.
 */
export const useToastContext = () => {
  const context = useContext(ToastContext)
  if (!context) throw new Error('useToastContext must be used within a ToastProvider')
  return context
}

/**
 * Uses the current messages of the toast context.
 */
export const useToastMessages = (limit?: number) => {
  const { messages } = useToastContext()
  return useMemo(() => {
    if (limit === undefined) return messages
    const start = Math.max(messages.length - limit, 0)
    const end = Math.min(start + limit, messages.length)
    return messages.slice(start, end)
  }, [messages, limit])
}
